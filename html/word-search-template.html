<!doctype html>
<html>
  <head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="initial-scale=1"/>
    <title>japanese fuzzy search dictionary</title>
    <style>
      html {
          font-size: 16px;
      }
      body {
          background-color: black;
          color: #ddd;
      }
      body a {
          color: #ddd;
      }
      h1 {
          font-size: 16px;
      }
      #filter input {
          border: 0;
          background-color: #eee;
          width: 9rem;
      }
      #results {
          margin-block-start: 1rem;
          font-size: 26px;
      }
    </style>
  </head>
  <body>
    <h1>japanese fuzzy search dictionary</h1>
    <div class="description">
      <ul>
        <li>includes the 15000 most frequent words</li>
        <li>finds words with similar spelling and pronunciation. for example, in case you hear a word and cant quite make out if it has a short or long vowel, or a "z" or "s", this search will find it anyway</li>
        <li>this is only done when entering readings in romaji, but searching words using kanji is also possible</li>
        <li>the page can be used offline after right click save page as. everything is contained in one html file</li>
        <li>supports regexp syntax. for example, word$ for only searching at the end, ^word for only searching at the beginning or . for wildcards</li>
      </ul>
    </div>
    <div id="filter">
      <input id="filter-input" placeholder="filter..."/>
      <button id="filter-reset">reset</button>
    </div>
    <div id="results">
    </div>
    <script>
      var words = {content};
      var abc_regexp = /[a-z]/

      function make_search_regexp(word) {
        var replacements = [
          [/tsu|zu/g, "#1"],
          [/ou/g, "#2"],
          [/ei|e/g, "#3"],
          [/sh|ch|j/g, "#4"],
          [/ii|i/g, "(i|ii)"],
          [/uu|u/g, "(u|uu)"],
          [/o/g, "(o|ou)"],
          [/t|d/g, "(t|d)"],
          [/kk|k|g/g, "(k|g|kk)"],
          [/pp|p|b/g, "(b|p|pp)"],
          [/ss|s|z/g, "(s|z|ss)"],
          [/nn|n/g, "(n|nn)"],
          [/#1/g, "(tsu|zu)"],
          [/#2/g, "(ou|o)"],
          [/#3/g, "(ei|e)"],
          [/#4/g, "(ch|j|sh)"]
        ]
        replacements.forEach(function(a) {
          word = word.replace(a[0], a[1])
        })
        return new RegExp(word)
      }

      function match(word, value) {
        word.includes(value) || word.includes
      }

      function init_filter() {
        var input = document.getElementById("filter-input")
        var button = document.getElementById("filter-reset")
        var results = document.getElementById("results")
        function on_filter() {
          if (0 == input.value.length || (2 > input.value.length && abc_regexp.test(input.value))) {
            results.innerHTML = ""
            return
          }
          var value = input.value.trim()
          var matches = []
          if (abc_regexp.test(value)) {
            var regexp = make_search_regexp(value)
            for (var i = 0; (i < words.length); i += 1) {
              if (regexp.test(words[i][1])) {
                var line = words[i][0] + " " + words[i][1] + " " + words[i][2].join("/")
                matches.push(line)
              }
            }
          }
          else {
            for (var i = 0; (i < words.length); i += 1) {
              if (words[i][0].includes(value)) {
                var line = words[i][0] + " " + words[i][1] + " " + words[i][2].join("/")
                matches.push(line)
              }
            }
          }
          results.innerHTML = matches.join("<br/>")
        }
        function on_reset() {
          input.value = ""
          on_filter()
        }
        input.addEventListener("keyup", on_filter)
        button.addEventListener("click", on_reset)
        return (input.addEventListener("change", on_filter))
      }

      init_filter()
    </script>
  </body>
</html>
